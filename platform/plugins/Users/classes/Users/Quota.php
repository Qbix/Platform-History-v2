<?php
/**
 * @module Users
 */
/**
 * Class representing 'Quota' rows in the 'Users' database
 * You can create an object of this class either to
 * access its non-static methods, or to actually
 * represent a quota row in the Users database.
 *
 * @class Users_Quota
 * @extends Base_Users_Quota
 */
class Users_Quota extends Base_Users_Quota
{
	/**
	 * The setUp() method is called the first time
	 * an object of this class is constructed.
	 * @method setUp
	 */
	function setUp()
	{
		parent::setUp();
		// INSERT YOUR CODE HERE
		// e.g. $this->hasMany(...) and stuff like that.
	}
	
	/**
	 * Check whether the given user can use some more units of the quota.
	 * For APIs, you might call this once for an app user, and once for a person user.
	 * @param {string} $userId the user that will be using the quota
	 * @param {string} $resourceId pass an empty string for global resource check, or for example a string beginning with Users::communityId()
	 * @param {string|array} $name the name of the quota, or you can pass the names of several quotas to check
	 * @param {boolean} [$throwIfQuota=false] pass true to throw an exception if one or more of the quotas have been reached
	 * @param {integer} [$units=1] how many units of the quota you expect the user will use
	 * @param {array} [$privileges=array()] any strings naming privileges the user has with respect to the resourceId that might increase the max of the quota
	 * @param {boolean} [$begin=true] whether to begin a database transaction, in which case you must call $quota->used($used) to commit the transaction.
	 * @return {Users_Quota} this object contains information on which quotas, if any were reached. If $throwIfQuota is true, then none were reached, but you will probably want to call ->used($units) on this object.
	 */
	static function check(
		$userId, 
		$resourceId, 
		$name, 
		$throwIfQuota = false, 
		$units = 1, 
		$privileges = array(),
		$begin = true)
	{
		if (is_string($name)) {
			$name = array($name);
		}
		$durations = array();
		$quotas = Q_Config::get('Users', 'quotas', array());
		foreach ($name as $n) {
			if (!isset($quotas[$n])) {
				continue;
			}
			$q = $quotas[$n];
			if (!is_array($q)) {
				throw new Q_Exception_BadValue(array(
					'internal' => "Users/quotas/$n",
					'problem' => "must be an array"
				));
			}
			$title = isset($q['title']) ? $q['title'] : $n;
			foreach ($q as $duration => $max) {
				if (!in_array($duration, $durations)) {
					$durations[] = (int)$duration;
				}
			}
		}
		if (empty($durations)) {
			return true;
		}
		$condition = '';
		rsort($durations);
		$condition = $largest = end($durations);
		$time = Users_Quota::db()->getCurrentTimestamp();
		foreach ($durations as $duration) {
			$startTime = date("Y-m-d h:i:s", $time - $duration);
			$condition .= "IF (insertedTime >= $startTime, $duration, $condition)";
		}
		$query = Users_Quota::select('SUM(1) si')->where(array(
			'userId' => $userId,
			'resourceId' => $resourceId,
			'insertedTime' => new Db_Range($time - $largest, true, false, null)
		));
		$queries = $query->shard();
		if ($begin) {
			$query = $query->begin();
		}
		$results = $query->fetchAll(PDO::FETCH_ASSOC);
		$quota = new Users_Quota(compact('userId', 'resourceId', 'name'));
		$quota->set(array(
			'begun' => $begin,
			'queries' => $queries
		));
		// todo: check the quotas
		// if any quotas were reached, then rollback and possibly throw exception
		// otherwise, return the Users_Quota object.
	}
	
	/**
	 * Insert a record of the user using some units of the quota
	 * For APIs, you might call this once for an app user, and once for a person user.
	 * You must call this to commit the transaction.
	 * @param {string} $userId the user that will be using the quota
	 * @param {string} $resourceId pass an empty string for global resource check, or for example a string beginning with Users::communityId()
	 * @param {string|array} $name the name of the quota, or you can pass the names of several quotas to record at once
	 * @param {integer} [$units=1] how many units of the quota the user has used
	 * @return {boolean} whether the quota record was inserted successfully
	 */
	function used($units = 1)
	{
		// commit transaction here
		// todo: actually save the row
		// todo: implement static ::commit() on Db_Mysql
		// and also on all autogenerated classes
		$this->units = $units;
		$this->save();
		if ($this->get('begun')) {
			$shards = array_keys($this->get('queries'));
			Users_Quota::commit($shards);
		}
	}

	/*
	 * Add any Users_Quota methods here, whether public or not
	 */
	 
	/**
	 * Implements the __set_state method, so it can work with
	 * with var_export and be re-imported successfully.
	 * @method __set_state
	 * @static
	 * @param {array} $array
	 * @return {Users_Quota} Class instance
	 */
	static function __set_state(array $array) {
		$result = new Users_Quota();
		foreach($array as $k => $v)
			$result->$k = $v;
		return $result;
	}
};