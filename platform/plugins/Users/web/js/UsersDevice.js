"use strict";
(function (Q, $) {

	var Users = Q.plugins.Users;

	Q.onReady.add(function () {
		if (!Q.info.isCordova || !window.PushNotification) {
			return;
		}
		// set appId when the application loads
		var appId = location.search.queryField('Q.Users.appId');
		if (appId) {
			localStorage.setItem("Q\tUsers.Device.appId", appId);
		}
	});

	/**
	 * Some methods related to Users.Device
	 * @class Users.Device
	 */
	Users.Device = {
		/**
		 * Subscribe to listen for push notifications
		 * if the current environment supports it.
		 * (Web Push, Cordova, etc.)
		 * @method subscribe
		 * @static
		 * @param {Function} callback
		 * @param {Object} options
		 * @param {Boolean} options.userVisibleOnly whether the returned push subscription
		 *   will only be used for messages whose effect is made visible to the user
		 * @param {String} options.applicationServerKey A public key your push server
		 *   will use to send messages to client apps via a push server. This value is
		 *   part of a signing key pair generated by your application server, and usable
		 *   with elliptic curve digital signature (ECDSA), over the P-256 curve.
		 */
		subscribe: function (callback, options) {
			this.adapter.subscribe(callback, options);
		},

		/**
		 * Unsubscribe to stop handling push notifications
		 * if we were previously subscribed
		 * @method unsubscribe
		 * @static
		 * @param {Function} callback
		 */
		unsubscribe: function (callback) {
			this.adapter.unsubscribe(callback);
		},

		/**
		 * Checks whether the user already has a subscription.
		 * @method subscribed
		 * @static
		 * @param {Boolean} callback Whether the user already has a subscription
		 */
		subscribed: function (callback) {
			this.adapter.subscribed(callback);
		},

		/**
		 * Event occurs when a notification comes in to be processed by the app.
		 * The handlers you add are supposed to process it.
		 * The notification might have brought the app back from the background,
		 * or not. Please see the documentation here:
		 * https://github.com/katzer/cordova-plugin-local-notifications
		 * @event onNotification
		 */
		onNotification: new Q.Event(),

		init: function (callback) {
			if (Q.info.isCordova && window.PushNotification) {
				// Android adapter
				this.adapter = Users.Device.Android;
			} else if ((Q.info.browser.name === 'chrome') || (Q.info.browser.name === 'firefox')) {
				// Chrome and Firefox
				this.adapter = Users.Device.Web;
			}
			this.adapter.init(callback);
		},

		adapter: null

	};

	// Adapter for Chrome and Firefox
	Users.Device.Web = {

		init: function (callback) {
			this.appConfig = Q.getObject('Q.Users.browserApps.' + Q.info.browser.name + '.' + Q.info.app);
			var self = this;
			if ('serviceWorker' in navigator && 'PushManager' in window) {
				console.log('Service Worker and Push is supported');
				navigator.serviceWorker.register('plugins/Users/js/sw.js')
					.then(function (swReg) {
						console.log('Service Worker is registered', swReg);
						self.serviceWorkerRegistration = swReg;
						callback(self.serviceWorkerRegistration);
					})
					.catch(function (error) {
						console.error('Service Worker Error', error);
					});
			} else {
				callback(null, new Error("Push messaging is not supported"));
			}
		},

		subscribe: function (callback, options) {
			var self = this;

			function urlB64ToUint8Array(base64String) {
				var padding = '='.repeat((4 - base64String.length % 4) % 4);
				var base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');
				var rawData = window.atob(base64);
				var outputArray = new Uint8Array(rawData.length);
				for (var i = 0; i < rawData.length; ++i) {
					outputArray[i] = rawData.charCodeAt(i);
				}
				return outputArray;
			}

			var appConfig = Q.getObject('Q.Users.browserApps.' + Q.info.browser.name + '.' + Q.info.app);
			var userVisibleOnly = true;
			if (options && !options.userVisibleOnly) {
				userVisibleOnly = false;
			}
			this.serviceWorkerRegistration.pushManager.subscribe({
				userVisibleOnly: userVisibleOnly,
				applicationServerKey: urlB64ToUint8Array(self.appConfig.publicKey)
			}).then(function (subscription) {
				_saveSubscription(subscription);
				callback(subscription);
			}).catch(function (e) {
				if (Notification.permission === 'denied') {
					console.warn('Permission for Notifications was denied');
				} else {
					console.warn('Unable to subscribe to push.', e);
				}
			});

			function _saveSubscription(subscription) {
				if (!subscription) {
					return;
				}
				subscription = JSON.parse(JSON.stringify(subscription));
				Q.req('Users/device', function (err, response) {
					if (!err) {
						Q.handle(Users.onDevice, [response.data]);
					}
				}, {
					method: 'post',
					fields: {
						deviceId: subscription.endpoint,
						auth: subscription.keys.auth,
						p256dh: subscription.keys.p256dh,
						appId: appConfig.appId
					}
				});
			}

		},

		unsubscribe: function (callback) {
			this.serviceWorkerRegistration.pushManager.getSubscription()
				.then(function (subscription) {
					if (subscription) {
						return subscription.unsubscribe();
					}
				})
				.catch(function (error) {
					console.log('Error unsubscribing', error);
				})
				.then(function () {
					//updateSubscriptionOnServer(null);
					console.log('User is unsubscribed.');
					callback(true);

				});
		},

		subscribed: function (callback) {
			this.serviceWorkerRegistration.pushManager.getSubscription()
				.then(function (subscription) {
					callback(!(subscription === null));
				});
		},

		serviceWorkerRegistration: null,

		appConfig: null

	};

	// Adapter for Android
	Users.Device.Android = {
		init: function (callback) {
			this.appConfig = Q.getObject('Q.Users.apps.android.' + Q.info.app);
			var appId = location.search.queryField('Q.Users.appId');
			if (appId) {
				localStorage.setItem("Q\tUsers.Device.appId", appId);
			}
			callback();
		},

		subscribe: function (callback, options) {
			var self = this;

			var push = PushNotification.init({
				android: {
					senderID: this.appConfig.senderId
				},
				browser: {
					pushServiceURL: 'http://push.api.phonegap.com/v1/push'
				},
				ios: {
					alert: true,
					badge: true,
					sound: true
				},
				windows: {}
			});

			push.on('registration', function (data) {
				var deviceId = data.registrationId;
				localStorage.setItem("Q\tUsers.Device.deviceId", deviceId);
				var appId = location.search.queryField('Q.Users.appId');
				if (appId) {
					localStorage.setItem("Q\tUsers.Device.appId", appId);
				}
				if (Q.Users.loggedInUser) {
					_registerDevice();
				}
				callback();
			});

			push.on('notification', function (data) {
				Users.Device.onNotification.handle(data);
			});

			push.on('error', function (e) {
				console.log("ERROR", e);
			});

			Users.login.options.onSuccess.set(function () {
				_registerDevice();
			}, 'Users.PushNotification');
			Users.logout.options.onSuccess.set(function () {
				PushNotification.setApplicationBadgeNumber(0);
			}, 'Users.PushNotifications');
			function _registerDevice(deviceId, appId) {
				var storedDeviceId = localStorage.getItem("Q\tUsers.Device.deviceId");
				var storedAppId = localStorage.getItem("Q\tUsers.Device.appId");
				deviceId = storedDeviceId || deviceId;
				appId = storedAppId || appId;
				if (!deviceId) {
					return;
				}
				Q.req('Users/device', function (err, response) {
					if (!err) {
						Q.handle(Users.onDevice, [response.data]);
					}
				}, {
					method: 'post',
					fields: {
						appId: appId,
						deviceId: deviceId
					}
				});
			}
		},

		unsubscribe: function (callback) {
			var storedDeviceId = localStorage.getItem("Q\tUsers.Device.deviceId");
			localStorage.removeItem("Q\tUsers.Device.deviceId");
			callback();
		},

		subscribed: function (callback) {
			var storedDeviceId = localStorage.getItem("Q\tUsers.Device.deviceId");
			if (storedDeviceId) {
				callback(true);
			} else {
				callback(false);
			}
		},

		serviceWorkerRegistration: null,

		appConfig: null
	};

})(Q, jQuery);
